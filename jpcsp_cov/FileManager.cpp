using namespace std;

//====================================================================================================
//The Free Edition of Java to C++ Converter limits conversion output to 100 lines per file.

//To purchase the Premium Edition, visit our website:
//https://www.tangiblesoftwaresolutions.com/order/order-java-to-cplus.html
//====================================================================================================

#include "FileManager.h"
#include "Settings.h"
#include "MemoryMap.h"
#include "Memory.h"

namespace jpcsp
{
	using FileNotFoundException = java::io::FileNotFoundException;
	using IOException = java::io::IOException;
	using namespace jpcsp::filesystems;
	using ByteBuffer = java::nio::ByteBuffer;
	using LinkedList = java::util::LinkedList;
	using List = java::util::List;
	using DeferredStub = jpcsp::format::DeferredStub;
	using Elf32 = jpcsp::format::Elf32;
	using Elf32Header = jpcsp::format::Elf32Header;
	using Elf32ProgramHeader = jpcsp::format::Elf32ProgramHeader;
	using Elf32SectionHeader = jpcsp::format::Elf32SectionHeader;
	using ShFlags = jpcsp::format::Elf32SectionHeader::ShFlags;
	using ShType = jpcsp::format::Elf32SectionHeader::ShType;
	using PBP = jpcsp::format::PBP;
	using PSP = jpcsp::format::PSP;
	using PSPModuleInfo = jpcsp::format::PSPModuleInfo;
	using Utilities = jpcsp::util::Utilities;
string FileManager::ElfInfo;
string FileManager::ProgInfo;
string FileManager::PbpInfo;
string FileManager::SectInfo;

	FileManager::FileManager(ByteBuffer *f)
	{
		//this.filePath = filePath;
		loadAndDefine(f);
	}

	FileManager::FileManager(SeekableDataInput *iso)
	{
	   /* this.iso=iso;
	    elfoffset = 0;
	    baseoffset = 0;
	     setActualFile(iso);
	     moduleInfo = new PSPModuleInfo();
	     deferredImports = new LinkedList<DeferredStub>();
	     try {
	      elf = new Elf32(iso);
	      processElf();
	     }catch(IOException e)
	     {
		
	     }*/

	}

	PSPModuleInfo *FileManager::getPSPModuleInfo()
	{
		return moduleInfo;
	}

	PBP *FileManager::getPBP()
	{
		return pbp;
	}

	Elf32 *FileManager::getElf32()
	{
		return elf;
	}

	ByteBuffer *FileManager::getActualFile()
	{
		return actualFile;
	}

	void FileManager::setActualFile(ByteBuffer *f)
	{
		actualFile = f;
	}

	void FileManager::loadAndDefine(ByteBuffer *f)
	{
		//SeekableRandomFile f = new SeekableRandomFile(filePath, "r");
		setActualFile(f);
		try
		{
			elfoffset = 0;
			baseoffset = 0;

			loadAddressLow = 0;
			loadAddressHigh = 0;

			moduleInfo = new PSPModuleInfo();
			deferredImports = list<DeferredStub*>();

			//makes sense put the more used first...

			/*try pbp format*/
			pbp = new PBP(getActualFile());
			if (pbp->getOffsetParam() > 0)
			{
				cout << pbp->readPSF(getActualFile()) << endl;
			}
			processPbp();
			if (getType() == FORMAT_PBP)
			{
				return;
			}
			/*end try pbp format*/

			/*try elf32 format*/
			elf = new Elf32(getActualFile());
			processElf();
			if (getType() == FORMAT_ELF)
			{
				return;
			}
			/*end try elf32 format*/


			/*try xxxx format*/
			/*try xxxx format*/


			//NONE FORMAT SELECTED OR DETECTED :(
		}
//JAVA TO C++ CONVERTER TODO TASK: There is no C++ equivalent to the exception 'finally' clause:
		finally
		{
			// f.close(); // close or let it open...
		}
	}

	int FileManager::getType()
	{
		return type;
	}

	void FileManager::processElf()
	{
		if (getElf32()->getHeader()->isValid())
		{
			type = FORMAT_ELF;
			readElf32Header();
			readElfProgramHeaders();
			readElfSectionHeaders();
		}
		else
		{
			cout << "NOT AN ELF FILE" << endl;
		}

	}

	void FileManager::readElf32Header()
	{
		if (!getElf32()->getHeader()->isMIPSExecutable())
		{
			cout << "NOT A MIPS executable" << endl;
		}

		if (getElf32()->getHeader()->isPRXDetected())
		{
			cout << "PRX detected, requires relocation" << endl;
			baseoffset = 0x08900000;
		}
		else if (getElf32()->getHeader()->requiresRelocation())
		{
			// seen in .elf's generated by pspsdk with BUILD_PRX=1 before conversion to .prx
			cout << "ELF requires relocation" << endl;
			baseoffset = 0x08900000;
		}

		ElfInfo = getElf32()->getElfInfo();
	}

	void FileManager::processPbp()
	{

		if (getPBP()->isValid())
		{

			if (Settings::get_instance()->readBoolOptions("emuoptions/pbpunpack"))
			{
				getPBP()->unpackPBP(getActualFile());
			}
			elfoffset = getPBP()->getOffsetPspData();
			getActualFile()->position(static_cast<int>(elfoffset)); //seek the new offset

//JAVA TO C++ CONVERTER TODO TASK: There is no C++ equivalent to 'toString':
			PbpInfo = getPBP()->toString(); //inteast this use PBP.getInfo()

			elf = new Elf32(getActualFile()); //the elf of pbp
			if (!getElf32()->getHeader()->isValid()) //probably not an elf
			{
			  getActualFile()->position(static_cast<int>(elfoffset)); //seek again to elfoffset
			  psp = new PSP(getActualFile());
			  if (psp->isValid()) //check if it is an encrypted file
			  {
				  cout << "Encrypted psp format.Not Supported!" << endl;
				  type = FORMAT_PSP;
				  return;
			  }
			}
			getPBP()->setElf32(elf); //composite the pbp...

			processElf();

			type = FORMAT_PBP;
		}
		else
		{
			elfoffset = 0;
			getActualFile()->position(0);
			getPBP()->setInfo("-----NOT A PBP FILE---------\n");
		}
	}

	void FileManager::readElfProgramHeaders()
	{
		vector<Elf32ProgramHeader*> programheaders = list<Elf32ProgramHeader*>();
		StringBuilder *phsb = new StringBuilder();


//====================================================================================================
//End of the allowed output for the Free Edition of Java to C++ Converter.

//To purchase the Premium Edition, visit our website:
//https://www.tangiblesoftwaresolutions.com/order/order-java-to-cplus.html
//====================================================================================================
